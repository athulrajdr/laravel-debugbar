{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#common-issues","title":"Common Issues","text":""},{"location":"faq/#the-debugbar-is-not-showing-up","title":"The debugbar is not showing up","text":"<ol> <li>Check if it's enabled in your environment:</li> </ol> <pre><code>'enabled' =&gt; env('DEBUGBAR_ENABLED', null)\n</code></pre> <ol> <li>Verify your environment settings</li> <li>Check if you're in debug mode</li> </ol>"},{"location":"faq/#performance-impact","title":"Performance Impact","text":"<p>Q: Will the debugbar slow down my application?</p> <p>A: The debugbar does add some overhead. That's why it's recommended to: - Only install for local development - Only enable needed collectors</p>"},{"location":"faq/#storage-issues","title":"Storage Issues","text":"<p>Q: Where is the data stored?</p> <p>A: By default, debugbar data is stored in:</p> <pre><code>storage/debugbar\n</code></pre> <p>You can change this in the configuration file.</p>"},{"location":"faq/#best-practices","title":"Best Practices","text":"<ol> <li>Never install in production</li> <li>Clear storage regularly</li> <li>Only enable needed collectors</li> </ol>"},{"location":"faq/#getting-help","title":"Getting Help","text":"<ul> <li>Check the GitHub Issues</li> <li>Join Laravel community channels</li> <li>Review the source code</li> </ul>"},{"location":"features/","title":"Features","text":"<p>Warning</p> <p>Debugbar can slow the application down (because it has to gather and render data). So when experiencing slowness, try disabling some of the collectors.</p>"},{"location":"features/#collectors","title":"Collectors","text":"<p>This package includes some custom collectors:</p> <ul> <li>QueryCollector: Show all queries, including binding + timing</li> <li>RouteCollector: Show information about the current Route.</li> <li>ViewCollector: Show the currently loaded views. (Optionally: display the shared data)</li> <li>EventsCollector: Show all events</li> <li>LaravelCollector: Show the Laravel version and Environment. (disabled by default)</li> <li>SymfonyRequestCollector: replaces the RequestCollector with more information about the request/response</li> <li>LogsCollector: Show the latest log entries from the storage logs. (disabled by default)</li> <li>FilesCollector: Show the files that are included/required by PHP. (disabled by default)</li> <li>ConfigCollector: Display the values from the config files. (disabled by default)</li> <li>CacheCollector: Display all cache events. (disabled by default)</li> </ul> <p>Bootstraps the following collectors for Laravel: - LogCollector: Show all Log messages - SymfonyMailCollector for Mail</p> <p>And the default collectors: - PhpInfoCollector - MessagesCollector - TimeDataCollector (With Booting and Application timing) - MemoryCollector - ExceptionsCollector</p> <p>It also provides a facade interface (Debugbar) for easy logging Messages, Exceptions and Time</p>"},{"location":"install/","title":"Installation","text":"<p>Danger</p> <p>Use the DebugBar only in development. Do not use Debugbar on publicly accessible websites, as it will leak information from stored requests (by design).</p> <p>Require this package with composer. It is recommended to only require the package for development.</p> <pre><code>composer require barryvdh/laravel-debugbar --dev\n</code></pre> <p>Laravel uses Package Auto-Discovery, so doesn't require you to manually add the ServiceProvider.</p> <p>The Debugbar will be enabled when <code>APP_DEBUG</code> is <code>true</code>.</p> <p>If you use a catch-all/fallback route, make sure you load the Debugbar ServiceProvider before your own App ServiceProviders.</p>"},{"location":"install/#laravel-without-auto-discovery","title":"Laravel without auto-discovery:","text":"<p>If you don't use auto-discovery, add the ServiceProvider to the providers list. For Laravel 11 or newer, add the ServiceProvider in bootstrap/providers.php. For Laravel 10 or older, add the ServiceProvider in config/app.php.</p> <pre><code>Barryvdh\\Debugbar\\ServiceProvider::class,\n</code></pre> <p>If you want to use the facade to log messages, add this within the <code>register</code> method of <code>app/Providers/AppServiceProvider.php</code> class:</p> <pre><code>public function register(): void\n{\n    $loader = \\Illuminate\\Foundation\\AliasLoader::getInstance();\n    $loader-&gt;alias('Debugbar', \\Barryvdh\\Debugbar\\Facades\\Debugbar::class);\n}\n</code></pre> <p>The profiler is enabled by default, if you have APP_DEBUG=true. You can override that in the config (<code>debugbar.enabled</code>) or by setting <code>DEBUGBAR_ENABLED</code> in your <code>.env</code>. See more options in <code>config/debugbar.php</code> You can also set in your config if you want to include/exclude the vendor files also (FontAwesome, Highlight.js and jQuery). If you already use them in your site, set it to false. You can also only display the js or css vendors, by setting it to 'js' or 'css'. (Highlight.js requires both css + js, so set to <code>true</code> for syntax highlighting)</p>"},{"location":"install/#copy-the-package-config-to-your-local-config-with-the-publish-command","title":"Copy the package config to your local config with the publish command:","text":"<pre><code>php artisan vendor:publish --provider=\"Barryvdh\\Debugbar\\ServiceProvider\"\n</code></pre>"},{"location":"install/#laravel-with-octane","title":"Laravel with Octane:","text":"<p>Make sure to add LaravelDebugbar to your flush list in <code>config/octane.php</code>.</p> <pre><code>    'flush' =&gt; [\n        \\Barryvdh\\Debugbar\\LaravelDebugbar::class,\n    ],\n</code></pre>"},{"location":"install/#lumen","title":"Lumen:","text":"<p>For Lumen, register a different Provider in <code>bootstrap/app.php</code>:</p> <pre><code>if (env('APP_DEBUG')) {\n $app-&gt;register(Barryvdh\\Debugbar\\LumenServiceProvider::class);\n}\n</code></pre> <p>To change the configuration, copy the file to your config folder and enable it:</p> <pre><code>$app-&gt;configure('debugbar');\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>You can now add messages using the Facade (when added), using the PSR-3 levels (debug, info, notice, warning, error, critical, alert, emergency):</p> <pre><code>Debugbar::info($object);\nDebugbar::error('Error!');\nDebugbar::warning('Watch out\u2026');\nDebugbar::addMessage('Another message', 'mylabel');\n</code></pre> <p>And start/stop timing:</p> <pre><code>Debugbar::startMeasure('render','Time for rendering');\nDebugbar::stopMeasure('render');\nDebugbar::addMeasure('now', LARAVEL_START, microtime(true));\nDebugbar::measure('My long operation', function() {\n    // Do something\u2026\n});\n</code></pre> <p>Or log exceptions:</p> <pre><code>try {\n    throw new Exception('foobar');\n} catch (Exception $e) {\n    Debugbar::addThrowable($e);\n}\n</code></pre> <p>There are also helper functions available for the most common calls:</p> <pre><code>// All arguments will be dumped as a debug message\ndebug($var1, $someString, $intValue, $object);\n\n// `$collection-&gt;debug()` will return the collection and dump it as a debug message. Like `$collection-&gt;dump()`\ncollect([$var1, $someString])-&gt;debug();\n\nstart_measure('render','Time for rendering');\nstop_measure('render');\nadd_measure('now', LARAVEL_START, microtime(true));\nmeasure('My long operation', function() {\n    // Do something\u2026\n});\n</code></pre> <p>If you want you can add your own DataCollectors, through the Container or the Facade:</p> <pre><code>Debugbar::addCollector(new DebugBar\\DataCollector\\MessagesCollector('my_messages'));\n//Or via the App container:\n$debugbar = App::make('debugbar');\n$debugbar-&gt;addCollector(new DebugBar\\DataCollector\\MessagesCollector('my_messages'));\n</code></pre> <p>By default, the Debugbar is injected just before <code>&lt;/body&gt;</code>. If you want to inject the Debugbar yourself, set the config option 'inject' to false and use the renderer yourself and follow http://phpdebugbar.com/docs/rendering.html</p> <pre><code>$renderer = Debugbar::getJavascriptRenderer();\n</code></pre> <p>Note: Not using the auto-inject, will disable the Request information, because that is added After the response. You can add the default_request datacollector in the config as alternative.</p>"},{"location":"usage/#enablingdisabling-on-run-time","title":"Enabling/Disabling on run time","text":"<p>You can enable or disable the debugbar during run time.</p> <pre><code>\\Debugbar::enable();\n\\Debugbar::disable();\n</code></pre> <p>NB. Once enabled, the collectors are added (and could produce extra overhead), so if you want to use the debugbar in production, disable in the config and only enable when needed.</p>"},{"location":"usage/#storage","title":"Storage","text":"<p>Debugbar remembers previous requests, which you can view using the Browse button on the right. This will only work if you enable <code>debugbar.storage.open</code> in the config. Make sure you only do this on local development, because otherwise other people will be able to view previous requests. In general, Debugbar should only be used locally or at least restricted by IP. It's possible to pass a callback, which will receive the Request object, so you can determine access to the OpenHandler storage.</p>"},{"location":"usage/#twig-integration","title":"Twig Integration","text":"<p>Laravel Debugbar comes with two Twig Extensions. These are tested with rcrowe/TwigBridge 0.6.x</p> <p>Add the following extensions to your TwigBridge config/extensions.php (or register the extensions manually)</p> <pre><code>'Barryvdh\\Debugbar\\Twig\\Extension\\Debug',\n'Barryvdh\\Debugbar\\Twig\\Extension\\Dump',\n'Barryvdh\\Debugbar\\Twig\\Extension\\Stopwatch',\n</code></pre> <p>The Dump extension will replace the dump function to output variables using the DataFormatter. The Debug extension adds a <code>debug()</code> function which passes variables to the Message Collector, instead of showing it directly in the template. It dumps the arguments, or when empty; all context variables.</p> <pre><code>{{ debug() }}\n{{ debug(user, categories) }}\n</code></pre> <p>The Stopwatch extension adds a stopwatch tag  similar to the one in Symfony/Silex Twigbridge.</p> <pre><code>{% stopwatch \"foo\" %}\n    \u2026some things that gets timed\n{% endstopwatch %}\n</code></pre>"}]}